jobs:
  build:
    executor: docker-executor
    steps:
      - checkout
      - setup_remote_docker
      - run:
          name: Build Docker Compose services
          command: |
            docker-compose build
            docker save swe40006_devops-backend:latest -o backend.tar
            docker save swe40006_devops-frontend:latest -o frontend.tar
      - persist_to_workspace:
          root: ~/project
          paths:
            - backend.tar
            - frontend.tar

  test:
    executor: docker-executor
    steps:
      - checkout
      - attach_workspace:
          at: ~/project
      - setup_remote_docker
      - run:
          name: Load Docker images (backend/frontend)
          command: |
            docker load -i ~/project/backend.tar
            docker load -i ~/project/frontend.tar
      - run:
          name: Start services with docker-compose
          command: docker-compose up -d
      # --- New steps for Selenium tests ---
      - run:
          name: Build Selenium test runner image
          # Assumes your test Dockerfile is at test/Dockerfile and source is in tests/
          command: docker build -t food-billing-selenium-tests -f test/Dockerfile tests/
      - run:
          name: Wait for services to be healthy (Optional but Recommended)
          # IMPORTANT: Services started with -d might not be instantly ready.
          # Add a command here to wait for your services (especially frontend)
          # to be accessible before running tests.
          # A simple sleep is a starting point, but polling a health endpoint is better.
          command: |
            echo "Waiting for services to start..."
            sleep 30 # Adjust sleep time as needed based on how long your app takes to start
            # More robust options:
            # Use a tool like `wait-for-it.sh` or `dockerize` to wait on the frontend port
            # Example (requires wait-for-it or similar):
            # curl -sL https://github.com/vishnubob/wait-for-it/raw/master/wait-for-it.sh -o /usr/local/bin/wait-for-it.sh
            # chmod +x /usr/local/bin/wait-for-it.sh
            # wait-for-it.sh frontend:5000 -t 60 # Replace 5000 with actual internal frontend port

      - run:
          name: Run integration tests (Selenium)
          command: |
            # Find the docker-compose network name. Assumes your docker-compose.yml
            # creates a default network (usually directoryname_default)
            DC_NETWORK=$(docker network ls -f name=.*_default --format "{{.Name}}" | head -n 1)
            echo "Running tests on network: $DC_NETWORK"

            # Run the test container, connecting it to the docker-compose network.
            # Use the service name 'frontend' (replace if your frontend service has a different name in docker-compose.yml)
            # and its internal port (replace 5000 if needed) for the APP_URL.
            # Resource limits (--shm-size, --cpus, --memory) might need tuning or removal
            # depending on your CircleCI executor size and requirements.
            docker run \
              --rm \
              --network $DC_NETWORK \
              --shm-size="2g" \
              # --cpus="1.5" # Uncomment if you need CPU limits
              # --memory="2g" # Uncomment if you need Memory limits
              -e APP_URL="http://backend:5000/" \
              food-billing-selenium-tests:latest

      # --- End of new steps for Selenium tests ---

      # The subsequent jobs (push, deploy) will only run if this test job succeeds.
      # If the 'docker run' command for the tests exits with a non-zero status,
      # this step (and thus the job) will fail.

  push:
    executor: docker-executor
    steps:
      - checkout
      - attach_workspace:
          at: ~/project
      - setup_remote_docker
      - run:
          name: Load Docker images
          command: |
            docker load -i ~/project/backend.tar
            docker tag swe40006_devops-backend:latest $ACR_NAME.azurecr.io/swe40006_devops-backend:latest

            docker load -i ~/project/frontend.tar
            docker tag swe40006_devops-frontend:latest $ACR_NAME.azurecr.io/swe40006_devops-frontend:latest
      - run:
          name: Push backend to ACR
          command: |
            echo $AZURE_PASSWORD | docker login $ACR_NAME.azurecr.io -u $AZURE_USERNAME --password-stdin
            docker push $ACR_NAME.azurecr.io/swe40006_devops-backend:latest
      - run:
          name: Push frontend to ACR
          command: |
            docker push $ACR_NAME.azurecr.io/swe40006_devops-frontend:latest

  deploy:
    executor: docker-executor
    steps:
      - checkout
      - run:
          name: Install Azure CLI and Kubectl
          command: |
            curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

            KUBECTL_VERSION=$(curl -sL https://dl.k8s.io/release/stable.txt)
            echo "Installing kubectl version $KUBECTL_VERSION"
            curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/kubectl
      - run:
          name: Login to Azure and set AKS credentials
          command: |
            az login --service-principal -u $AZURE_SP_APP_ID -p $AZURE_SP_CLIENT_SECRET --tenant $AZURE_TENANT_ID
            az aks get-credentials --resource-group "$AZURE_RESOURCE_GROUP" --name "$AKS_CLUSTER_NAME" --overwrite-existing
      - run:
          name: Deploy backend and frontend to AKS
          command: |
            kubectl apply -f k8s/db-secret.yaml
            kubectl apply -f k8s/backend-deployment.yaml
            kubectl apply -f k8s/backend-service.yaml
            kubectl apply -f k8s/frontend-deployment.yaml
            kubectl apply -f k8s/frontend-service.yaml
      - run:
          name: Restart Deployments to Pick Up Changes
          command: |
            kubectl rollout restart deployment backend-deployment
            kubectl rollout restart deployment frontend-deployment

workflows:
  build_test_push:
    jobs:
      - build
      - test:
          requires:
            - build
      - push:
          requires:
            - test
      - deploy:
          requires:
            - push