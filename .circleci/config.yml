version: 2.1

executors:
  docker-executor:
    docker:
      - image: cimg/python:3.11
    working_directory: ~/project

jobs:
  build:
    executor: docker-executor
    steps:
      - checkout
      - setup_remote_docker
      - run:
          name: Build Docker Compose services
          command: |
            docker-compose build
            docker save swe40006_devops-backend:latest -o backend.tar
            docker save swe40006_devops-frontend:latest -o frontend.tar
      - persist_to_workspace:
          root: ~/project
          paths:
            - backend.tar
            - frontend.tar

  test:
    executor: docker-executor
    steps:
      - checkout
      - attach_workspace:
          at: ~/project
      - setup_remote_docker
      # --- NEW DEBUG STEP ---
      # This step will show you the exact files present in ~/project
      # after checkout and workspace attachment. LOOK AT THIS OUTPUT CAREFULLY.
      - run:
          name: List files in test working directory
          command: ls -al ~/project
      # --- END NEW DEBUG STEP ---

      - run:
          name: Load Docker images (backend/frontend)
          command: |
            docker load -i ~/project/backend.tar
            docker load -i ~/project/frontend.tar

      - run:
          name: Start services with docker-compose
          # Keeping -f here for now, as the 'stat' error occurred with this path.
          # The ls -al output will tell us if this path is correct or why it's failing.
          command: docker-compose -f ~/project/docker-compose.yml up -d

      - run:
          name: Build Selenium test runner image
          command: docker build -t food-billing-selenium-tests -f tests/Dockerfile tests/

      # --- Wait for Database Service ---
      # IMPORTANT: Replace 'database_service_name' with the actual name of your DB service in docker-compose.yml
      # IMPORTANT: Replace '5432' with the internal port your DB container listens on
      # IMPORTANT: Update 'docker-compose logs database_service_name' if DB service name is different
      - run:
                name: Wait for Database Service (Debug)
                command: |
                  curl -sL https://github.com/vishnubob/wait-for-it/raw/master/wait-for-it.sh -o /usr/local/bin/wait-for-it.sh
                  chmod +x /usr/local/bin/wait-for-it.sh

                  echo "Waiting for database service at db:5432..."

                  # Try waiting...
                  /usr/local/bin/wait-for-it.sh db:5432 -t 60 --strict

                  # Store the exit code of the wait-for-it command
                  wait_exit_code=$?

                  if [ $wait_exit_code -ne 0 ]; then
                    echo "wait-for-it.sh failed with exit code $wait_exit_code. Attempting to capture DB logs..."

                    # --- Add debug checks before running docker-compose logs ---
                    echo "Current directory: $(pwd)"
                    echo "Contents of ~/project:"
                    ls -al ~/project
                    echo "--- End Contents of ~/project ---"
                    # --- End debug checks ---

                    # Now attempt to get logs. If this fails, the previous ls -al should show why.
                    # IMPORTANT: Ensure the -f path ~/project/docker-compose.yml is correct based on your ls -al output
                    docker-compose -f ~/project/docker-compose.yml logs db

                    echo "Database service did not become available within 60 seconds."
                    exit 1 # Fail the step
                  else
                    echo "wait-for-it.sh succeeded."
                    echo "Database service is available."
                  fi
      # --- End Wait for Database Service ---

      # --- Wait for Backend Service ---
      # IMPORTANT: Replace 'backend' with the actual name of your Backend service in docker-compose.yml
      # IMPORTANT: Replace '5000' with the internal port your Backend container listens on
      # IMPORTANT: Update 'docker-compose logs backend' if Backend service name is different
      - run:
          name: Wait for Backend Service to Respond
          command: |
            # wait-for-it.sh is already downloaded from the previous step
            echo "Waiting for backend service at backend:5000..."
            # Using -f for consistency
            /usr/local/bin/wait-for-it.sh backend:5000 -t 60 --strict || {
              echo "Backend service did not become available within 60 seconds."
              docker-compose -f ~/project/docker-compose.yml logs backend # Using -f here
              exit 1 # Fail the step if backend wait fails
            }
            echo "Backend service is available."

      # --- Run Integration Tests (Selenium) ---
      # IMPORTANT: Ensure APP_URL points to the correct backend service name and internal port
      # If your backend service is NOT named 'backend' or does NOT listen on port 5000 internally, update below
      - run:
          name: Run integration tests (Selenium)
          command: |
            DC_NETWORK=$(docker network ls -f name=.*_default --format "{{.Name}}" | head -n 1)
            echo "Running tests on network: $DC_NETWORK"
            docker run \
              --rm \
              --network $DC_NETWORK \
              --shm-size="2g" \
              -e APP_URL="http://backend:5000/" \ # <-- Verify backend:5000 matches your docker-compose
              food-billing-selenium-tests:latest

      # --- Capture Backend Logs (Keep this!) ---
      # This step will run *after* the tests (pass or fail) and show backend logs.
      # IMPORTANT: Update 'docker-compose logs backend' if Backend service name is different
      - run:
          name: Capture Backend Logs
          command: docker-compose -f ~/project/docker-compose.yml logs backend # Using -f here
          when: always # Always run this step

  push:
    executor: docker-executor
    steps:
      - checkout
      - attach_workspace:
          at: ~/project
      - setup_remote_docker
      - run:
          name: Load Docker images
          command: |
            docker load -i ~/project/backend.tar
            docker tag swe40006_devops-backend:latest $ACR_NAME.azurecr.io/swe40006_devops-backend:latest

            docker load -i ~/project/frontend.tar
            docker tag swe40006_devops-frontend:latest $ACR_NAME.azurecr.io/swe40006_devops-frontend:latest
      - run:
          name: Push backend to ACR
          command: |
            echo $AZURE_PASSWORD | docker login $ACR_NAME.azurecr.io -u $AZURE_USERNAME --password-stdin
            docker push $ACR_NAME.azurecr.io/swe40006_devops-backend:latest
      - run:
          name: Push frontend to ACR
          command: |
            docker push $ACR_NAME.azurecr.io/swe40006_devops-frontend:latest

  deploy:
    executor: docker-executor
    steps:
      - checkout
      - run:
          name: Install Azure CLI and Kubectl
          command: |
            curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

            KUBECTL_VERSION=$(curl -sL https://dl.k8s.io/release/stable.txt)
            echo "Installing kubectl version $KUBECTL_VERSION"
            curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/kubectl
      - run:
          name: Login to Azure and set AKS credentials
          command: |
            az login --service-principal -u $AZURE_SP_APP_ID -p $AZURE_SP_CLIENT_SECRET --tenant $AZURE_TENANT_ID
            az aks get-credentials --resource-group "$AZURE_RESOURCE_GROUP" --name "$AKS_CLUSTER_NAME" --overwrite-existing
      - run:
          name: Deploy backend and frontend to AKS
          command: |
            kubectl apply -f k8s/db-secret.yaml
            kubectl apply -f k8s/backend-deployment.yaml
            kubectl apply -f k8s/backend-service.yaml
            kubectl apply -f k8s/frontend-deployment.yaml
            kubectl apply -f k8s/frontend-service.yaml
      - run:
          name: Restart Deployments to Pick Up Changes
          command: |
            kubectl rollout restart deployment backend-deployment
            kubectl rollout restart deployment frontend-deployment

workflows:
  build_test_push:
    jobs:
      - build
      - test:
          requires:
            - build
      - push:
          requires:
            - test
      - deploy:
          requires:
            - push